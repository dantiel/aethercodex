DEFAULT_PORT = 4567
port = window.AETHER_PORT ? DEFAULT_PORT
ws   = null
reconnectAttempts = 0
maxReconnectAttempts = 10
baseReconnectDelay = 1000  # 1 second
lastPongTime = null


connectWebSocket = ->
  try
    # Purify previous dimensional channel
    if ws?.readyState == WebSocket.OPEN or ws?.readyState == WebSocket.CONNECTING
      ws.close()
      ws = null

    log 'system', "üîÆ Initiating connection ritual to ws://127.0.0.1:#{port}/ws..."
    ws = new WebSocket "ws://127.0.0.1:#{port}/ws"
    setupWebSocketHandlers()
  catch e
    log 'error', "üîÆ Connection ritual failed: #{e.message}"
    scheduleReconnect()


setupWebSocketHandlers = ->
  ws.onopen = ->
    log 'system', 'üóùÔ∏è Gate opened.'
    reconnectAttempts = 0  # Reset on successful connection
    
  ws.onerror = (e) ->
    console.log e
    log 'error', "üîÆ Dimensional breach detected: #{e.message ? e.type ? 'connection error'}"
  
  ws.onping = -> lastPongTime = Date.now()
  ws.onpong = -> lastPongTime = Date.now()
    
  ws.onclose = (e) ->
    log 'error', "üåÄ Gate sealed code=#{e.code} reason=#{e.reason}"
    # Attempt reconnection unless it was a normal close (code 1000)
    if e.code != 1000
      scheduleReconnect()
    
  # Check for missed pongs every 30 seconds
  setInterval ->
    if lastPongTime and (Date.now() - lastPongTime) > 30000
      ws.close()
  , 30000
  ws.onmessage = handleMessage
  

scheduleReconnect = ->
  return if reconnectAttempts >= maxReconnectAttempts

  if reconnectAttempts >= maxReconnectAttempts
    log 'error', "üîÆ Maximum reconnection attempts reached. Gateway sealed."
    return
    
  delay = baseReconnectDelay * Math.pow(2, Math.min(reconnectAttempts, 5))
  reconnectAttempts++
  
  log 'system', "üîÆ Attempting dimensional reconnection #{reconnectAttempts}/#{maxReconnectAttempts} in #{delay}ms..."
  setTimeout connectWebSocket, delay
  


# Message persistence
STORAGE_KEY = 'aether_messages'
MAX_MESSAGES = 50


saveMessages = ->
  messages = Array.from(document.querySelectorAll('#messages > div')).map (el) ->
    className: el.className
    innerHTML: el.innerHTML
  localStorage.setItem STORAGE_KEY, JSON.stringify(messages.slice(-MAX_MESSAGES))


loadMessages = ->
  try
    stored = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]')
    stored.forEach (msg) ->
      console.log "load from storage:", msg
      el = document.createElement 'div'
      el.className = msg.className
      el.innerHTML = msg.innerHTML
      document.getElementById('messages').appendChild el
    m = document.getElementById('messages')
    m.scrollTop = m.scrollHeight
  catch e
    console.warn 'Failed to load messages:', e
  
  do loadMessagesDone


loadMessagesDone = ->
  do connectWebSocket


log = (cls, html) ->
  console.log "logging #{cls}", html
  el = document.createElement 'div'
  el.className = cls
  el.innerHTML = html
  m = document.getElementById 'messages'
  m.appendChild el
  m.scrollTop = m.scrollHeight
  saveMessages()


renderTools = (tools) ->
  return unless tools?.length
  tools.forEach (t, idx) ->
    btn = document.createElement 'button'
    btn.textContent = "Consecrate #{t.tool}"
    btn.onclick = ->
      ws.send JSON.stringify method: 'tool', params: t
    log 'system', "Proposed tool ##{idx+1}: <pre>#{JSON.stringify(t,null,2)}</pre>"
    document.getElementById('messages').appendChild btn


# Enhanced status display with live feedback
showStatus = (type, data) ->
  timestamp = new Date(data.timestamp * 1000).toLocaleTimeString() if data.timestamp
  
  console.log "showStatus", timestamp, type, data
  
  switch type
    when 'thinking'
      log 'status', "#{data.message || 'Consulting the astral codex...'} <small>#{timestamp || ''}</small>"
    when 'file_reading'
      log 'status', "#{data.message} <small>#{timestamp || ''}</small>"    
    when 'divination'
      log 'status', "#{data.message || 'Consulting the astral codex...'} <small>#{timestamp || ''}</small>"
    when 'file_read_complete'
      log 'status', """
        <details>
          <summary>#{data.message} <small>#{timestamp || ''}</small></summary>
          #{data.content}
        </details>"""
    when 'file_read_fail'
      log 'status', "‚ùå #{data.message} <small>#{timestamp || ''}</small>"
    when 'file_creating'
      log 'status', "#{data.message} <small>#{timestamp || ''}</small>"
    when 'file_created'
      log 'status', """
        <details>
          <summary>#{data.message} <small>#{timestamp || ''}</small></summary>
          #{data.content}
        </details>"""
    when 'tool_starting'
      log 'status', "‚ö° Invoking <code>#{data.tool}</code>... <small>#{timestamp || ''}</small>"
      if data.args and Object.keys(data.args).length > 0 and JSON.stringify(data.args).length < 200
        log 'status', "&nbsp;&nbsp;‚Ü≥ Args: <code>#{JSON.stringify(data.args)}</code>"
    when 'file_patching'
      log 'status', "#{data.message} <small>#{timestamp || ''}</small>"
    when 'file_patched'
      log 'status', """
        <details>
          <summary>#{data.message} <small>#{timestamp || ''}</small></summary>
          #{data.diff}
        </details>"""
    when 'file_patched_fail'
      log 'status', """
        <details>
          <summary>#{data.message} <small>#{timestamp || ''}</small></summary>
          #{data.diff}
        # </details>"""
    when 'command_executing'
      log 'status', "#{data.message} <small>#{timestamp || ''}</small>"
    when 'command_completed'
      log 'status', "#{data.message} <small>#{timestamp || ''}</small>"      # Show args if not too verbose
    when 'file_renaming'
      log 'status', "#{data.message} <small>#{timestamp || ''}</small>"
    when 'file_renamed'
      log 'status', "#{data.message} <small>#{timestamp || ''}</small>"      
    when 'memory_storing'
      log 'status', "#{data.message} <small>#{timestamp || ''}</small>"
    when 'memory_stored'
      log 'status', "#{data.message} <small>#{timestamp || ''}</small>"
    when 'memory_searching'
      log 'status', "#{data.message} <small>#{timestamp || ''}</small>"
    when 'memory_found'
      log 'status', "#{data.message} <small>#{timestamp || ''}</small>"        
    when 'info'
      log 'status', "#{data.message} <small>#{timestamp || ''}</small>"    
    when 'tool_completed'
      if data.result?.error
        log 'status', "‚ùå Tool <code>#{data.tool}</code> failed: #{data.result.error} <small>#{timestamp || ''}</small>"
        # Show error details if available
        if data.result.error
          log 'system', "<details><summary>‚ùå Error details</summary><pre>#{data.result.error}</pre></details>"
      else
        log 'status', "‚úÖ Tool <code>#{data.tool}</code> completed <small>#{timestamp || ''}</small>"
      
      # Show tool results if available (only for successful tools)
      if data.result and Object.keys(data.result).length > 0 and not data.result?.error
        resultJson = JSON.stringify(data.result, null, 2)
        if resultJson.length > 200
          log 'system', "<details><summary>üìã #{data.tool} result (#{resultJson.length} chars)</summary><pre>#{resultJson}</pre></details>"
        else
          log 'system', "&nbsp;&nbsp;‚Ü≥ Result: <pre style='display:inline; background:none;'>#{resultJson}</pre>"
    when 'ai_response'
      if data.content
        log 'ai', data.content
      else
        log 'status', "üí≠ AI responding... <small>#{timestamp || ''}</small>"
    when 'plan_announced'
      log 'status', "üìãPlan: #{data.steps?.join(' ‚Üí ')} <small>#{timestamp || ''}</small>"
    when 'processing'
      log 'status', "#{data.message} <small>#{timestamp || ''}</small>"
    when 'completed'
      log 'status', "#{data.summary || 'Completed'} <small>#{timestamp || ''}</small>"
    when 'server_error'
      log 'error', "#{data.error} <small>#{timestamp || ''}</small>"


# WebSocket event handlers
# ws.onopen  = -> log 'system', 'üóùÔ∏è Gate opened.'
# ws.onerror = (e) -> log 'error', "WS error: #{e.message ? e}"
# ws.onclose = (e) -> log 'error', "Closed code=#{e.code} reason=#{e.reason}"
# ws.onmessage = (e) ->
handleMessage = (e) ->
  data = JSON.parse e.data
  switch data.method
    when 'status'
      showStatus data.result.type, data.result.data
    when 'answer'
      if data.result.logs?
        data.result.logs.forEach (l) ->
          switch l.type
            when 'prelude' then log 'ai', l.data s
            when 'say'     then log 'ai', l.data.message      
      if data.result.tools? and data.result.tools.length > 0
        toolsJson = JSON.stringify(data.result.tools, null, 2)
        if toolsJson.length > 300
          log 'system', "<details><summary>üîß Tools (#{toolsJson.length} chars)</summary><pre>#{toolsJson}</pre></details>"
        else
          log 'system', "<pre>#{toolsJson}</pre>"        
        renderTools data.result.tools
    when 'toolResult'
      resultJson = JSON.stringify(data.result, null, 2)
      if resultJson.length > 300
        log 'system', "<details><summary>üîß Tool Result (#{resultJson.length} chars)</summary><pre>#{resultJson}</pre></details>"
      else
        log 'system', "<pre>#{resultJson}</pre>"    
    when 'completion'
      log 'ai', "<pre>#{data.result.snippet}</pre>"
    when 'error'
      log 'error', "<pre>#{data.result.error}\\n#{(data.result.backtrace or []).join('\\n')}</pre>"
    else
      log 'system', "<pre>#{JSON.stringify(data,null,2)}</pre>"


send = ->
  text = document.getElementById('chat-input').value
  return unless text?.length
  ws.send JSON.stringify method: 'askAI', params: { prompt: text, record: true }
  log 'user', text
  document.getElementById('chat-input').value = ''


document.getElementById('send-btn').onclick = send


# Load messages when page loads
window.addEventListener 'DOMContentLoaded', loadMessages
